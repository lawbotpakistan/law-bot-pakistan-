export const config = { runtime: "nodejs" };

import { createClient } from "@supabase/supabase-js";
import fetch from "node-fetch";
import PDFDocument from "pdfkit";
import streamToBuffer from "stream-to-array"; // small helper replaced by manual buffer conversion below

const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const LEGAL_BUCKET = "legal_docs";

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY || !GEMINI_API_KEY) {
  console.warn("Missing env. Set SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY and GEMINI_API_KEY.");
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

/**
 * Utility: make PDF buffer from title + body text
 */
async function generatePdfBuffer(title, bodyText) {
  const doc = new PDFDocument({ size: "A4", margin: 50 });
  const chunks = [];
  return new Promise((resolve, reject) => {
    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);

    // Simple PDF layout
    doc.fontSize(18).text(title, { align: "center" });
    doc.moveDown();
    doc.fontSize(11).text(`Generated by LawBot Pakistan — ${new Date().toLocaleString()}`, { align: "left" });
    doc.moveDown();
    doc.fontSize(12).text(bodyText, { align: "left' " , lineGap: 4 });
    doc.moveDown(2);
    doc.fontSize(9).fillColor("gray").text("Disclaimer: This is informational only and not legal representation.", { align: "left" });

    doc.end();
  });
}

/**
 * Call Gemini (basic generative call)
 * Note: adjust endpoint if Google updates API. This uses the REST key-style call.
 */
async function callGemini(prompt) {
  const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`;

  const payload = {
    // simple payload structure — if your Gemini model requires a different body, replace per Google docs
    contents: [{ parts: [{ text: prompt }] }],
  };

  const resp = await fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  const data = await resp.json();
  // attempt several places depending on returned shape
  const text =
    data?.candidates?.[0]?.content?.parts?.[0]?.text ||
    data?.output?.[0]?.content?.[0]?.text ||
    JSON.stringify(data).slice(0, 2000);

  return { raw: data, text };
}

export default async function handler(req, res) {
  try {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }

    const body = await req.json();
    // expected fields: userId, query
    const { userId, query, payer_name, payer_ref, file_url, amount } = body;

    if (!userId) return res.status(400).json({ error: "Missing userId" });

    // If payment submission included, insert into payments table
    if (payer_name && payer_ref && file_url && amount) {
      const { error: payErr } = await supabase.from("payments").insert([
        {
          user_id: userId,
          payer_name,
          payer_ref,
          file_url,
          amount,
          status: "pending",
        },
      ]);
      if (payErr) return res.status(500).json({ error: payErr.message });
      // continue — they may not be asking a query right now
    }

    // If no query provided, return early
    if (!query) {
      return res.status(200).json({ ok: true, message: "Payment recorded (if provided)." });
    }

    // Check profile subscription
    const { data: profile, error: profileErr } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", userId)
      .single();
    if (profileErr) return res.status(500).json({ error: profileErr.message });

    const now = new Date();
    if (profile.subscription_status !== "active" || (profile.subscription_expires_at && new Date(profile.subscription_expires_at) < now)) {
      return res.status(403).json({ error: "Subscription expired or not approved yet" });
    }

    // Build a law-specific system prompt referencing pakistanlawsite.com
    const systemPrompt = `You are a legal assistant for Pakistani law. Answer strictly about Pakistani law and reference PakistanLawSite (pakistanlawsite.com) where applicable. Provide steps, citations, and a short template for a legal document if requested. Include a disclaimer: this is not a substitute for a licensed lawyer.`;

    const fullPrompt = `${systemPrompt}\n\nUser question:\n${query}\n\nPlease produce: 1) concise legal answer, 2) a ready-to-copy legal document template (if relevant).`;

    // Call Gemini
    const gemini = await callGemini(fullPrompt);
    const assistantText = gemini.text || "No reply from AI.";

    // Save chat
    await supabase.from("chats").insert([{ user_id: userId, prompt: query, response: assistantText }]);

    // Generate PDF document from assistant answer (title + body)
    const title = `LawBot - Document for ${profile.full_name || userId}`;
    const pdfBuffer = await generatePdfBuffer(title, assistantText);

    // Save PDF to Supabase storage
    const filePath = `${userId}/${Date.now()}_doc.pdf`;
    const { data: uploadData, error: uploadErr } = await supabase.storage
      .from(LEGAL_BUCKET)
      .upload(filePath, pdfBuffer, { contentType: "application/pdf", upsert: false });

    if (uploadErr) {
      console.error("Upload error:", uploadErr);
      return res.status(500).json({ error: "Failed to upload PDF" });
    }

    // create a signed URL valid for 7 days
    const { data: signedData, error: signedErr } = await supabase.storage
      .from(LEGAL_BUCKET)
      .createSignedUrl(filePath, 60 * 60 * 24 * 7);

    if (signedErr) {
      console.error("Signed URL error:", signedErr);
    }

    const pdfUrl = signedData?.signedUrl || null;

    // Return assistant text + pdf url
    return res.status(200).json({ reply: assistantText, pdf_url: pdfUrl });
  } catch (err) {
    console.error("generate.js error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
